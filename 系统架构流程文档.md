# A2UI + A2A + OpenAI 系统架构流程文档

## 概述

本文档详细说明从用户通过前端页面交互，到最终结果渲染的完整技术流程。系统采用 **A2UI（Agent-to-UI）** 协议进行前后端UI通信，采用 **A2A（Agent-to-Agent）** 协议进行Agent间通信，并通过子Agent调用 **OpenAI API** 获取智能结果。

---

## 系统架构图

```
用户浏览器 (前端)
    ↓ (SSE连接)
Main-Agent (主代理服务器)
    ↓ (A2A协议)
子Agent (Weather-Agent / Flight-Agent)
    ↓ (HTTP API)
OpenAI API
    ↓ (返回结果)
子Agent → Main-Agent → A2UI生成 → 前端渲染 → 用户
```

---

## 详细流程说明

### 阶段1: 前端页面初始化

**位置**: `main-agent/web/index.html` + `main-agent/web/app.js`

**执行时机**: 浏览器加载页面时，按代码顺序同步执行

**详细流程**:

#### 1.1 HTML页面加载（index.html）

**时机**: 用户访问 `http://localhost:3000`，浏览器开始解析HTML

**执行顺序**:
1. **第1-18行**: 加载HTML结构和CSS样式
2. **第20行**: 显示Surface ID占位符 `<span id="surfaceId"></span>`
3. **第21行**: 创建空的app容器 `<div id="app"></div>`
4. **第22行**: 加载JavaScript模块 `<script type="module" src="/app.js"></script>`

**此时状态**: 
- HTML DOM已创建，但内容为空
- JavaScript尚未执行

---

#### 1.2 JavaScript模块加载（app.js）

**时机**: 浏览器解析到 `<script>` 标签后，立即加载并执行 `app.js`

**执行顺序**:

**步骤1: 设置Surface ID（第1-2行）**
```javascript
const surfaceId = "main";
document.getElementById("surfaceId").textContent = surfaceId;
```
- **执行时机**: 模块加载时立即执行（同步）
- **作用**: 设置surfaceId常量，并更新页面上的显示文本
- **结果**: 页面显示 "Surface: main"

**步骤2: 初始化状态对象（第4-9行）**
```javascript
const state = {
  componentMap: new Map(),  // 组件定义映射
  dataModel: {},            // 数据模型
  rootId: null,             // 根组件ID
};
```
- **执行时机**: 模块加载时立即执行（同步）
- **作用**: 创建前端状态管理对象
- **结果**: 
  - `componentMap`: 空的Map，用于存储组件定义
  - `dataModel`: 空对象，用于存储数据模型
  - `rootId`: null，表示尚未确定根组件

**步骤3: 定义工具函数（第11-76行）**
- `setPath()`: 设置数据模型路径值
- `getPath()`: 获取数据模型路径值
- `resolveText()`: 解析文本引用（严格v0.8-like：只支持literalString或path）
- `normalizeComponent()`: 规范化组件定义
- `applyContents()`: 应用数据模型更新
- `buildElement()`: 根据组件定义构建DOM元素
- `render()`: 渲染整个UI树
- `postUserAction()`: 发送用户动作到服务器

**执行时机**: 模块加载时立即定义（同步），但函数体尚未执行

---

#### 1.3 建立SSE连接（关键时机）

**时机**: 模块加载完成后，代码执行到第194-196行时

**代码位置**: `app.js` 第194-196行
```javascript
// ===== SSE 接收 A2UI（v0.8-like）=====
const es = new EventSource(
  `/ui/stream?surfaceId=${encodeURIComponent(surfaceId)}`
);
```

**执行过程**:
1. **创建EventSource对象**: 浏览器立即发起HTTP GET请求到 `/ui/stream?surfaceId=main`
2. **请求格式**:
   ```
   GET /ui/stream?surfaceId=main HTTP/1.1
   Host: localhost:3000
   Accept: text/event-stream
   ```
3. **浏览器行为**: 
   - 保持HTTP连接打开
   - 等待服务器发送SSE格式的数据
   - 自动处理SSE协议（`text/event-stream`）

**重要**: 这个连接是**立即建立**的，不等待任何用户交互。一旦JavaScript执行到这里，连接就开始建立。

---

#### 1.4 注册SSE消息处理器（第198-243行）

**时机**: EventSource对象创建后，立即注册事件监听器

**代码**:
```javascript
es.onmessage = (evt) => {
  let msg;
  try {
    msg = JSON.parse(evt.data);
  } catch {
    return;
  }
  // 处理消息...
};
```

**执行时机**: 
- **注册时机**: 模块加载时立即注册（同步）
- **触发时机**: 当服务器通过SSE发送消息时异步触发

**消息处理逻辑**:
- **第206-214行**: 如果收到 `surfaceUpdate`，更新 `componentMap`
- **第216-225行**: 如果收到 `dataModelUpdate`，更新 `dataModel`（严格v0.8-like格式）
- **第227-236行**: 如果收到 `beginRendering`，设置 `rootId` 并触发首次渲染（严格v0.8-like格式）
- **第242-243行**: 如果收到 `surfaceUpdate` 或 `dataModelUpdate`，触发增量渲染

**此时状态**:
- SSE连接已建立（或正在建立中）
- 消息处理器已注册，等待服务器发送消息
- 页面显示 "Surface: main"，但 `#app` 容器仍为空

---

### 阶段2: Main-Agent 接收SSE连接并发送初始UI

**位置**: `main-agent/server.js` 第402-422行（路由处理） + 第146-253行（sendInitialUI函数）

**执行时机**: 前端发起 `GET /ui/stream` 请求时，服务器立即处理

---

#### 2.1 接收SSE连接请求

**时机**: 前端执行 `new EventSource()` 时，HTTP请求到达服务器

**代码位置**: `server.js` 第402-422行

**执行顺序**:

**步骤1: 路由匹配（第402行）**
```javascript
app.get("/ui/stream", (req, res) => {
```
- **时机**: Express路由匹配到 `GET /ui/stream`
- **请求参数**: `req.query.surfaceId = "main"`

**步骤2: 提取Surface ID（第403行）**
```javascript
const surfaceId = String(req.query.surfaceId || "main");
```
- **时机**: 路由处理函数开始执行
- **结果**: `surfaceId = "main"`

**步骤3: 设置SSE响应头（第404行）**
```javascript
setSseHeaders(res);
```
- **时机**: 立即执行
- **函数定义**: 第29-35行
```javascript
function setSseHeaders(res) {
  res.status(200);
  res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
  res.setHeader("Cache-Control", "no-cache, no-transform");
  res.setHeader("Connection", "keep-alive");
  res.write(":\n\n");  // SSE初始空消息
}
```
- **作用**: 
  - 设置HTTP状态码200
  - 设置Content-Type为 `text/event-stream`
  - 禁用缓存
  - 保持连接打开
  - 发送SSE初始空消息（`: ` + 两个换行符）

**步骤4: 启动心跳定时器（第407行）**
```javascript
const pingTimer = setInterval(() => res.write(":\n\n"), 15000);
```
- **时机**: 连接建立后立即启动
- **作用**: 每15秒发送一个空SSE消息（`: ` + 两个换行符），保持连接活跃
- **格式**: `:\n\n`（SSE心跳消息）

**步骤5: 记录SSE连接（第410-412行）**
```javascript
const old = sseBySurface.get(surfaceId);
if (old?.pingTimer) clearInterval(old.pingTimer);
sseBySurface.set(surfaceId, { res, pingTimer });
```
- **时机**: 心跳启动后立即执行
- **作用**: 
  - 检查是否已有该surfaceId的连接
  - 如果有旧连接，清除其心跳定时器
  - 将新连接存储到 `sseBySurface` Map中
- **数据结构**: `Map<surfaceId, {res: Response, pingTimer: Timer}>`

**步骤6: 调用sendInitialUI发送初始UI（第415行）**
```javascript
sendInitialUI(surfaceId, res);
```
- **时机**: 连接记录后**立即同步调用**
- **重要**: 这是**同步执行**的，会立即发送所有初始UI消息

**步骤7: 注册连接关闭处理器（第417-421行）**
```javascript
req.on("close", () => {
  clearInterval(pingTimer);
  const cur = sseBySurface.get(surfaceId);
  if (cur?.res === res) sseBySurface.delete(surfaceId);
});
```
- **时机**: 注册事件监听器（不立即执行）
- **作用**: 当客户端断开连接时，清理心跳定时器和连接记录

---

#### 2.2 sendInitialUI函数详细执行（第146-253行）

**时机**: 在路由处理函数中同步调用（第415行）

**执行顺序**:

**消息1: 发送UI组件目录（surfaceUpdate）**

**代码位置**: 第148-224行
```javascript
sseSend(res, {
  surfaceUpdate: {
    surfaceId,
    components: [
      { id: "root", component: { Column: {...} } },
      { id: "title", component: { Text: {...} } },
      { id: "input", component: { TextField: {...} } },
      { id: "submitBtn", component: { Button: {...} } },
      { id: "submitText", component: { Text: {...} } },
      { id: "resultArea", component: { Column: {...} } },
      { id: "weatherCard", component: { Card: {...} } },
      { id: "flightCard", component: { Card: {...} } },
    ],
  },
});
```

**sseSend函数**（第25-27行）:
```javascript
function sseSend(res, obj) {
  res.write(`data: ${JSON.stringify(obj)}\n\n`);
}
```

**发送的SSE消息格式**:
```
data: {"surfaceUpdate":{"surfaceId":"main","components":[...]}}

```

**组件定义详情**:
- **root** (Column): 根容器，包含 `["title", "input", "submitBtn", "resultArea"]`
- **title** (Text): 标题 "A2A + A2UI(v0.8-like) Demo"，usageHint="h2"
- **input** (TextField): 输入框，label="输入需求（天气/机票）"，绑定到 `/form/query`
- **submitBtn** (Button): 提交按钮，action.name="submit"，context包含query路径
- **submitText** (Text): 按钮文本 "提交"
- **resultArea** (Column): 结果区域容器，包含 `["weatherCard", "flightCard"]`
- **weatherCard** (Card): 天气卡片，title="天气"，body绑定到 `/weather/temp_text`
- **flightCard** (Card): 机票卡片，title="机票"，body绑定到 `/flights/options_text`

**消息2: 初始化表单数据模型（第227-233行）**
```javascript
sseSend(res, {
  dataModelUpdate: {
    surfaceId,
    path: "/form",
    contents: [{ key: "query", valueString: "" }],
  },
});
```

**发送的SSE消息格式**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/form","contents":[{"key":"query","valueString":""}]}}

```

**作用**: 初始化 `/form/query` 为空字符串

**消息3: 初始化天气数据模型（第235-241行）**
```javascript
sseSend(res, {
  dataModelUpdate: {
    surfaceId,
    path: "/weather",
    contents: [{ key: "temp_text", valueString: "（等待查询）" }],
  },
});
```

**发送的SSE消息格式**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/weather","contents":[{"key":"temp_text","valueString":"（等待查询）"}]}}

```

**作用**: 初始化 `/weather/temp_text` 为占位文本

**消息4: 初始化机票数据模型（第243-249行）**
```javascript
sseSend(res, {
  dataModelUpdate: {
    surfaceId,
    path: "/flights",
    contents: [{ key: "options_text", valueString: "（等待查询）" }],
  },
});
```

**发送的SSE消息格式**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/flights","contents":[{"key":"options_text","valueString":"（等待查询）"}]}}

```

**作用**: 初始化 `/flights/options_text` 为占位文本

**消息5: 触发渲染（第252行）**
```javascript
sseSend(res, { beginRendering: { surfaceId, root: "root" } });
```

**发送的SSE消息格式**:
```
data: {"beginRendering":{"surfaceId":"main","root":"root"}}

```

**作用**: 通知前端开始渲染，根组件ID为 "root"

---

#### 2.3 消息发送顺序总结

**执行顺序**（同步，立即完成）:
1. ✅ **消息1**: `surfaceUpdate` - 发送所有组件定义
2. ✅ **消息2**: `dataModelUpdate` - 初始化 `/form/query = ""`
3. ✅ **消息3**: `dataModelUpdate` - 初始化 `/weather/temp_text = "（等待查询）"`
4. ✅ **消息4**: `dataModelUpdate` - 初始化 `/flights/options_text = "（等待查询）"`
5. ✅ **消息5**: `beginRendering` - 触发前端渲染

**时间线**:
```
T0: 前端发起 GET /ui/stream
T1: 服务器设置SSE响应头（~1ms）
T2: 启动心跳定时器（~1ms）
T3: 记录连接（~1ms）
T4: 调用sendInitialUI()（同步）
    ├─ T4.1: 发送消息1 surfaceUpdate（~1ms）
    ├─ T4.2: 发送消息2 dataModelUpdate /form（~1ms）
    ├─ T4.3: 发送消息3 dataModelUpdate /weather（~1ms）
    ├─ T4.4: 发送消息4 dataModelUpdate /flights（~1ms）
    └─ T4.5: 发送消息5 beginRendering（~1ms）
T5: 注册连接关闭处理器（~1ms）
T6: 路由处理函数返回（连接保持打开）
```

**重要**: 所有5条消息都是在**同一个请求处理中同步发送**的，总耗时通常 < 10ms。

---

### 阶段3: 前端接收SSE消息并渲染UI

**位置**: `main-agent/web/app.js` 第198-243行（消息处理） + 第79-172行（DOM构建）

**执行时机**: 服务器发送SSE消息时，浏览器的EventSource自动触发 `onmessage` 事件

---

#### 3.1 接收消息1: surfaceUpdate

**时机**: 服务器发送第一条 `surfaceUpdate` 消息后，浏览器EventSource触发 `onmessage`

**代码执行**: `app.js` 第204-220行

**步骤1: 解析消息（第198-204行）**
```javascript
es.onmessage = (evt) => {
  let msg;
  try {
    msg = JSON.parse(evt.data);
  } catch {
    return;  // JSON解析失败，忽略消息
  }
```
- **evt.data**: 服务器发送的 `data: {...}` 中的JSON字符串
- **结果**: `msg = { surfaceUpdate: { surfaceId: "main", components: [...] } }`

**步骤2: 处理surfaceUpdate（第206-214行）**
```javascript
if (msg.surfaceUpdate) {
  const comps = msg.surfaceUpdate.components || [];
  for (const c of comps) {
    const normalized = normalizeComponent(c);
    if (normalized?.id && normalized?.type) {
      state.componentMap.set(normalized.id, normalized);
    }
  }
}
```

**normalizeComponent函数**（第50-54行）:
```javascript
function normalizeComponent(c) {
  const comp = c?.component || {};
  const type = Object.keys(comp)[0];
  return { id: c.id, type, payload: comp[type] || {} };
}
```

**执行过程**:
- 遍历所有组件定义
- 规范化每个组件（提取id、type、payload）
- 存储到 `state.componentMap` 中

**此时状态**:
- `state.componentMap` 包含7个组件：root, title, input, submitBtn, submitText, resultArea, weatherCard, flightCard
- `state.dataModel` 仍为空对象
- `state.rootId` 仍为 null

**步骤3: 触发增量渲染检查（第238行）**
```javascript
if (msg.surfaceUpdate || msg.dataModelUpdate) render();
```
- **执行**: 由于 `msg.surfaceUpdate` 存在，调用 `render()`
- **render函数**（第174-179行）:
```javascript
function render() {
  if (!state.rootId) return;  // ⚠️ rootId为null，直接返回，不渲染
  const app = document.getElementById("app");
  app.innerHTML = "";
  app.appendChild(buildElement(state.rootId));
}
```
- **结果**: 因为 `rootId` 为 null，`render()` 立即返回，**不进行渲染**

---

#### 3.2 接收消息2-4: dataModelUpdate（3条消息）

**时机**: 服务器连续发送3条 `dataModelUpdate` 消息

**消息2: /form数据模型更新**

**代码执行**: `app.js` 第216-225行
```javascript
if (msg.dataModelUpdate) {
  // 严格：只接受 path + contents
  const basePath = msg.dataModelUpdate.path;
  const contents = msg.dataModelUpdate.contents;
  if (typeof basePath === "string" && Array.isArray(contents)) {
    applyContents(basePath, contents);
  } else {
    console.warn("Ignored non-v0.8 dataModelUpdate:", msg.dataModelUpdate);
  }
}
```

**重要变化**: 
- **严格v0.8-like**: 只接受 `path + contents` 格式
- **移除兼容**: 不再支持旧的 `patch` 格式
- **验证**: 如果格式不正确，输出警告并忽略

**applyContents函数**（第56-77行）:
```javascript
/**
 * 严格 v0.8-like dataModelUpdate：path + contents
 * contents item 支持：valueString/valueNumber/valueBool/valueJson
 */
function applyContents(basePath, contents) {
  const base =
    typeof basePath === "string" && basePath.length > 0 ? basePath : "/";

  for (const item of contents || []) {
    const fullPath = (base.endsWith("/") ? base : base + "/") + item.key;

    if (item.valueString != null)
      setPath(state.dataModel, fullPath, item.valueString);
    else if (item.valueNumber != null)
      setPath(state.dataModel, fullPath, item.valueNumber);
    else if (item.valueBool != null)
      setPath(state.dataModel, fullPath, item.valueBool);
    else if (item.valueJson != null)
      setPath(state.dataModel, fullPath, item.valueJson);
    else setPath(state.dataModel, fullPath, "");
  }
}
```

**执行过程**:
- `basePath = "/form"`
- `contents = [{ key: "query", valueString: "" }]`
- `fullPath = "/form/query"`
- 调用 `setPath(state.dataModel, "/form/query", "")`

**setPath函数**（第11-23行）:
```javascript
function setPath(obj, path, value) {
  const parts = path.split("/").filter(Boolean);  // ["form", "query"]
  let cur = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const k = parts[i];
    cur[k] = cur[k] ?? {};  // 创建中间对象
    cur = cur[k];
  }
  cur[parts[parts.length - 1]] = value;  // 设置最终值
}
```

**结果**: `state.dataModel = { form: { query: "" } }`

**消息3: /weather数据模型更新**

**执行过程**: 类似消息2
- `basePath = "/weather"`
- `contents = [{ key: "temp_text", valueString: "（等待查询）" }]`
- 调用 `setPath(state.dataModel, "/weather/temp_text", "（等待查询）")`

**结果**: `state.dataModel = { form: { query: "" }, weather: { temp_text: "（等待查询）" } }`

**消息4: /flights数据模型更新**

**执行过程**: 类似消息2
- `basePath = "/flights"`
- `contents = [{ key: "options_text", valueString: "（等待查询）" }]`
- 调用 `setPath(state.dataModel, "/flights/options_text", "（等待查询）")`

**结果**: `state.dataModel = { form: { query: "" }, weather: { temp_text: "（等待查询）" }, flights: { options_text: "（等待查询）" } }`

**每次消息后**: 都会触发 `render()`（第238行），但因为 `rootId` 仍为 null，**不进行渲染**

---

#### 3.3 接收消息5: beginRendering（关键消息）

**时机**: 服务器发送 `beginRendering` 消息

**代码执行**: `app.js` 第227-236行
```javascript
if (msg.beginRendering) {
  // 严格：只接受 beginRendering.root
  const root = msg.beginRendering.root;
  if (typeof root === "string" && root) {
    state.rootId = root;
    render();
    return;
  }
  console.warn("Ignored non-v0.8 beginRendering:", msg.beginRendering);
}
```

**重要变化**: 
- **严格v0.8-like**: 只接受 `beginRendering.root` 字段
- **移除兼容**: 不再支持 `rootId` 字段
- **验证**: 如果格式不正确，输出警告并忽略

**执行过程**:
1. 提取 `root = msg.beginRendering.root`（必须是字符串）
2. 验证 `root` 是否为非空字符串
3. 设置 `state.rootId = root`
4. **调用 `render()`** - 这是**首次真正的渲染**

**render函数执行**（第174-179行）:
```javascript
function render() {
  if (!state.rootId) return;  // ✅ 现在rootId="root"，继续执行
  const app = document.getElementById("app");
  app.innerHTML = "";  // 清空容器
  app.appendChild(buildElement(state.rootId));  // 构建并添加根元素
}
```

**buildElement函数执行**（第79-172行）:

**调用1: buildElement("root")**
- 查找组件定义: `state.componentMap.get("root")`
- 类型: `Column`
- 执行Column分支（第89-95行）:
```javascript
if (type === "Column") {
  const el = document.createElement("div");
  el.className = "col";
  const list = payload?.children?.explicitList || [];  // ["title", "input", "submitBtn", "resultArea"]
  for (const childId of list) {
    el.appendChild(buildElement(childId));  // 递归构建子元素
  }
  return el;
}
```

**调用2: buildElement("title")**
- 类型: `Text`
- 执行Text分支（第97-102行）:
```javascript
if (type === "Text") {
  const tag = payload.usageHint === "h2" ? "h2" : "div";
  const el = document.createElement(tag);  // <h2>
  el.textContent = resolveText(payload.text);  // "A2A + A2UI(v0.8-like) Demo"
  return el;
}
```

**resolveText函数**（第35-48行）:
```javascript
/**
 * 严格 v0.8-like：
 * - 只支持 literalString 或 path 引用
 * - 不支持 literal / valueString 等混用字段
 */
function resolveText(ref) {
  if (!ref) return "";
  if (typeof ref === "string") return ref;

  if (ref.literalString != null) return String(ref.literalString);
  if (ref.path) return String(getPath(state.dataModel, ref.path) ?? "");

  return "";
}
```
- **严格v0.8-like**: 只支持 `literalString` 或 `path`，不再支持 `literal`、`valueString` 等
- `payload.text = { literalString: "A2A + A2UI(v0.8-like) Demo" }`
- 返回: `"A2A + A2UI(v0.8-like) Demo"`

**调用3: buildElement("input")**
- 类型: `TextField`
- 执行TextField分支（第104-122行）:
```javascript
if (type === "TextField") {
  const wrap = document.createElement("div");
  const label = document.createElement("div");
  label.className = "muted";
  label.textContent = resolveText(payload.label);  // "输入需求（天气/机票）"
  
  const input = document.createElement("input");
  const bindPath = payload.text?.path;  // "/form/query"
  input.value = String(getPath(state.dataModel, bindPath) ?? "");  // ""
  
  input.addEventListener("input", () => {
    if (bindPath) setPath(state.dataModel, bindPath, input.value);
  });
  
  wrap.appendChild(label);
  wrap.appendChild(input);
  return wrap;
}
```

**调用4: buildElement("submitBtn")**
- 类型: `Button`
- 执行Button分支（第124-152行）:
```javascript
if (type === "Button") {
  const btn = document.createElement("button");
  btn.textContent = "Button";  // 默认文本

  // v0.8-like：Button.child 引用一个 Text 组件
  if (payload.child) {
    const childDef = state.componentMap.get(payload.child);  // "submitText"
    if (childDef?.type === "Text") {
      btn.textContent = resolveText(childDef.payload?.text) || "Button";  // "提交"
    }
  }

  btn.addEventListener("click", async () => {
    const context = {};
    for (const item of payload?.action?.context || []) {
      const k = item.key;  // "query"
      const p = item.value?.path;  // "/form/query"
      context[k] = p ? getPath(state.dataModel, p) : undefined;
    }
    await postUserAction({
      name: payload?.action?.name || "action",  // "submit"
      surfaceId,
      context,
    });
  });

  return btn;
}
```

**重要变化**: 
- **简化**: 移除了对 `payload.text` 的兜底处理
- **严格**: 只支持通过 `child` 引用Text组件的方式

**调用5: buildElement("resultArea")**
- 类型: `Column`
- 类似root，包含 `["weatherCard", "flightCard"]`

**调用6: buildElement("weatherCard")**
- 类型: `Card`
- 执行Card分支（第154-167行）:
```javascript
if (type === "Card") {
  const card = document.createElement("div");
  card.className = "card";
  const h3 = document.createElement("h3");
  h3.textContent = resolveText(payload.title);  // "天气"
  const body = document.createElement("pre");
  body.textContent = resolveText(payload.body);  // 从 /weather/temp_text 读取
  card.appendChild(h3);
  card.appendChild(body);
  return card;
}
```

**resolveText解析body**:
- `payload.body = { path: "/weather/temp_text" }`
- `getPath(state.dataModel, "/weather/temp_text")` → `"（等待查询）"`

**调用7: buildElement("flightCard")**
- 类似weatherCard，body绑定到 `/flights/options_text` → `"（等待查询）"`

**最终DOM结构**:
```html
<div id="app">
  <div class="col">
    <h2>A2A + A2UI(v0.8-like) Demo</h2>
    <div>
      <div class="muted">输入需求（天气/机票）</div>
      <input value="" />
    </div>
    <button>提交</button>
    <div class="col">
      <div class="card">
        <h3>天气</h3>
        <pre>（等待查询）</pre>
      </div>
      <div class="card">
        <h3>机票</h3>
        <pre>（等待查询）</pre>
      </div>
    </div>
  </div>
</div>
```

**结果**: 用户看到完整的初始UI界面

---

#### 3.4 消息接收时间线

**浏览器EventSource处理SSE消息的顺序**:

```
T0: 服务器发送消息1 surfaceUpdate
T1: 浏览器触发onmessage（消息1）
    ├─ 更新componentMap（7个组件）
    └─ 调用render() → 因rootId=null，不渲染

T2: 服务器发送消息2 dataModelUpdate /form
T3: 浏览器触发onmessage（消息2）
    ├─ 更新dataModel.form.query = ""
    └─ 调用render() → 因rootId=null，不渲染

T4: 服务器发送消息3 dataModelUpdate /weather
T5: 浏览器触发onmessage（消息3）
    ├─ 更新dataModel.weather.temp_text = "（等待查询）"
    └─ 调用render() → 因rootId=null，不渲染

T6: 服务器发送消息4 dataModelUpdate /flights
T7: 浏览器触发onmessage（消息4）
    ├─ 更新dataModel.flights.options_text = "（等待查询）"
    └─ 调用render() → 因rootId=null，不渲染

T8: 服务器发送消息5 beginRendering
T9: 浏览器触发onmessage（消息5）
    ├─ 设置rootId = "root"
    └─ 调用render() → ✅ 首次真正渲染
        ├─ 清空#app
        ├─ buildElement("root")
        │   ├─ buildElement("title") → <h2>
        │   ├─ buildElement("input") → <input>
        │   ├─ buildElement("submitBtn") → <button>
        │   └─ buildElement("resultArea")
        │       ├─ buildElement("weatherCard") → <div class="card">
        │       └─ buildElement("flightCard") → <div class="card">
        └─ 添加到DOM
```

**总耗时**: 通常 < 50ms（取决于DOM操作性能）

---

### 阶段4: 用户交互 - 输入并提交

**位置**: `main-agent/web/app.js` 第105-123行（TextField） + 第125-158行（Button）

**执行时机**: 用户在前端页面进行交互时

---

#### 4.1 用户输入文本

**时机**: 用户在输入框中输入字符时

**代码位置**: `app.js` 第115-117行（在buildElement("input")时注册）

**执行过程**:

**步骤1: 用户输入字符**
- 用户在 `<input>` 元素中输入文本（如："查询北京明天的天气和到上海的机票"）
- 浏览器触发 `input` 事件

**步骤2: 事件处理器执行**
```javascript
// app.js 第115-117行
input.addEventListener("input", () => {
  if (bindPath) setPath(state.dataModel, bindPath, input.value);
});
```

**执行过程**:
- `bindPath = "/form/query"`（在构建时设置）
- `input.value = "查询北京明天的天气和到上海的机票"`
- 调用 `setPath(state.dataModel, "/form/query", "查询北京明天的天气和到上海的机票")`

**结果**: 
- `state.dataModel.form.query = "查询北京明天的天气和到上海的机票"`
- **注意**: 此时**不触发render()**，因为这是用户输入事件，不是SSE消息

**此时状态**:
- 数据模型已更新
- UI显示用户输入的文本（浏览器原生input行为）
- 用户可以看到输入框中的文本

---

#### 4.2 用户点击提交按钮

**时机**: 用户点击"提交"按钮时

**代码位置**: `app.js` 第136-149行（在buildElement("submitBtn")时注册）

**执行过程**:

**步骤1: 用户点击按钮**
- 用户点击 `<button>提交</button>`
- 浏览器触发 `click` 事件

**步骤2: 事件处理器执行**
```javascript
// app.js 第136-149行
btn.addEventListener("click", async () => {
  const context = {};
  for (const item of payload?.action?.context || []) {
    const k = item.key;  // "query"
    const p = item.value?.path;  // "/form/query"
    context[k] = p ? getPath(state.dataModel, p) : undefined;
  }
  
  await postUserAction({
    name: payload?.action?.name || "action",  // "submit"
    surfaceId,
    context,
  });
});
```

**执行过程**:
1. **构建context对象**:
   - 遍历 `payload.action.context`（在组件定义中）
   - `item = { key: "query", value: { path: "/form/query" } }`
   - `k = "query"`
   - `p = "/form/query"`
   - `context["query"] = getPath(state.dataModel, "/form/query")` → `"查询北京明天的天气和到上海的机票"`

2. **调用postUserAction**:
   - `name = "submit"`
   - `surfaceId = "main"`
   - `context = { query: "查询北京明天的天气和到上海的机票" }`

**步骤3: postUserAction函数执行**
```javascript
// app.js 第181-191行
async function postUserAction(userAction) {
  const r = await fetch("/ui/event", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userAction }),
  });
  if (!r.ok) {
    const t = await r.text();
    console.error("userAction failed:", t);
  }
}
```

**HTTP请求详情**:
```
POST /ui/event HTTP/1.1
Host: localhost:3000
Content-Type: application/json

{
  "userAction": {
    "name": "submit",
    "surfaceId": "main",
    "context": {
      "query": "查询北京明天的天气和到上海的机票"
    }
  }
}
```

**执行时机**: 
- **同步**: 立即发起HTTP请求
- **异步**: 等待服务器响应（不阻塞UI）

**此时状态**:
- HTTP请求已发送
- 前端等待服务器响应
- UI仍可交互（但用户通常等待结果）

---

### 阶段5: Main-Agent 处理用户动作

**位置**: `main-agent/server.js` 第425-487行

**执行时机**: 前端发送 `POST /ui/event` 请求到达服务器时

---

#### 5.1 接收并解析请求

**时机**: Express路由匹配到 `POST /ui/event`

**代码位置**: `server.js` 第425-437行

**执行顺序**:

**步骤1: 路由匹配（第425行）**
```javascript
app.post("/ui/event", async (req, res) => {
```

**步骤2: 提取请求数据（第426-428行）**
```javascript
const { userAction } = req.body || {};
const surfaceId = userAction?.surfaceId || "main";
const name = userAction?.name;
```
- **req.body**: Express中间件已解析JSON（`app.use(express.json())`）
- **结果**: 
  - `surfaceId = "main"`
  - `name = "submit"`

**步骤3: 提取查询内容（第436行）**
```javascript
const query = String(userAction?.context?.query || "");
```
- **结果**: `query = "查询北京明天的天气和到上海的机票"`

**步骤4: 验证SSE连接（第430-432行）**
```javascript
const conn = sseBySurface.get(surfaceId);
if (!conn?.res)
  return res.status(409).json({ error: "No active stream for surfaceId" });
```
- **检查**: 是否存在该surfaceId的活跃SSE连接
- **如果不存在**: 返回409错误，请求结束
- **如果存在**: `conn = { res: Response, pingTimer: Timer }`

**步骤5: 验证动作名称（第434行）**
```javascript
if (name !== "submit") return res.json({ ok: true });
```
- **如果name不是"submit"**: 直接返回成功，不处理
- **如果name是"submit"**: 继续执行

**步骤6: 验证查询内容（第437行）**
```javascript
if (!query.trim()) return res.status(400).json({ error: "Empty query" });
```
- **如果query为空**: 返回400错误
- **如果query不为空**: 继续执行

---

#### 5.2 发送加载状态（立即执行）

**时机**: 验证通过后，立即发送（在调用子Agent之前）

**代码位置**: `server.js` 第439-453行

**执行顺序**:

**消息1: 更新天气加载状态**
```javascript
// server.js 第440-446行
sseSend(conn.res, {
  dataModelUpdate: {
    surfaceId,
    path: "/weather",
    contents: [{ key: "temp_text", valueString: "查询中..." }],
  },
});
```

**发送的SSE消息**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/weather","contents":[{"key":"temp_text","valueString":"查询中..."}]}}

```

**消息2: 更新机票加载状态**
```javascript
// server.js 第447-453行
sseSend(conn.res, {
  dataModelUpdate: {
    surfaceId,
    path: "/flights",
    contents: [{ key: "options_text", valueString: "查询中..." }],
  },
});
```

**发送的SSE消息**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/flights","contents":[{"key":"options_text","valueString":"查询中..."}]}}

```

**执行时机**: 
- **同步执行**: 立即发送，不等待
- **总耗时**: < 1ms

**前端接收**: 
- 浏览器EventSource立即接收这两条消息
- 触发 `onmessage` 事件
- 更新 `state.dataModel`
- 调用 `render()`，UI显示"查询中..."

---

#### 5.3 并行调用子Agent（A2A协议）

**时机**: 加载状态发送后，立即开始（异步）

**代码位置**: `server.js` 第455-460行

**执行顺序**:

**步骤1: 启动并行调用**
```javascript
// server.js 第457-460行
try {
  const [weatherArtifact, flightArtifact] = await Promise.all([
    sendSubscribe(WEATHER_AGENT_URL, { query }),
    sendSubscribe(FLIGHT_AGENT_URL, { query }),
  ]);
```

**执行过程**:
- **Promise.all**: 同时启动两个异步操作
- **sendSubscribe(WEATHER_AGENT_URL, { query })**: 调用天气Agent
- **sendSubscribe(FLIGHT_AGENT_URL, { query })**: 调用机票Agent
- **await**: 等待两个调用都完成

**时间线**:
```
T0: 开始并行调用
    ├─ T0.1: 启动Weather-Agent调用（异步）
    └─ T0.2: 启动Flight-Agent调用（异步）

T1-TN: 两个调用并行执行（详见阶段6和阶段7）
    ├─ Weather-Agent处理中...
    └─ Flight-Agent处理中...

TN+1: 两个调用都完成
    ├─ weatherArtifact = { kind: "weather", data: {...} }
    └─ flightArtifact = { kind: "flights", data: {...} }
```

**重要**: 这两个调用是**真正的并行**，不会相互阻塞。总耗时 = max(Weather-Agent耗时, Flight-Agent耗时)

---

### 阶段6: A2A协议 - Agent发现与调用

**位置**: `main-agent/server.js` 第64-143行（sendSubscribe函数）

**执行时机**: Main-Agent调用 `sendSubscribe()` 时（阶段5.3中）

**调用方式**: 两个并行调用
- `sendSubscribe(WEATHER_AGENT_URL, { query })`
- `sendSubscribe(FLIGHT_AGENT_URL, { query })`

---

#### 6.1 sendSubscribe函数执行流程（以Weather-Agent为例）

**函数签名**: `server.js` 第77行
```javascript
async function sendSubscribe(baseUrl, input, timeoutMs = 20000)
```

**参数**:
- `baseUrl = "http://localhost:3001"`（WEATHER_AGENT_URL）
- `input = { query: "查询北京明天的天气和到上海的机票" }`
- `timeoutMs = 20000`（默认20秒）

**执行顺序**:

**步骤1: 创建超时控制器（第83-84行）**
```javascript
const ac = new AbortController();
const timer = setTimeout(() => ac.abort(), timeoutMs);
```
- **时机**: 函数开始执行时立即创建
- **作用**: 设置20秒超时，如果子Agent未响应则中止请求

**步骤2: Agent发现（Discovery）- 获取Agent Card**

**代码位置**: 第78行调用 `fetchAgentCard(baseUrl)`

**fetchAgentCard函数**（第65-73行）:
```javascript
async function fetchAgentCard(baseUrl) {
  if (agentCardCache.has(baseUrl)) return agentCardCache.get(baseUrl);
  const url = `${baseUrl}/.well-known/agent-card.json`;
  const r = await fetch(url);
  if (!r.ok) throw new Error(`AgentCard fetch failed: ${url} ${r.status}`);
  const card = await r.json();
  agentCardCache.set(baseUrl, card);
  return card;
}
```

**执行过程**:
1. **检查缓存**（第66行）:
   - `agentCardCache` 是Map结构（第23行定义）
   - 如果已缓存，直接返回（避免重复请求）

2. **发起HTTP请求**（第67-68行）:
   ```
   GET http://localhost:3001/.well-known/agent-card.json HTTP/1.1
   ```
   - **时机**: 如果缓存未命中，立即发起请求
   - **等待**: 等待子Agent响应

3. **子Agent响应**（Weather-Agent第20-28行）:
   ```json
   {
     "name": "weather-agent",
     "version": "0.0.1",
     "endpoints": {
       "sendSubscribe": "http://localhost:3001/tasks/sendSubscribe"
     }
   }
   ```

4. **解析并缓存**（第70-72行）:
   - 解析JSON响应
   - 存储到 `agentCardCache`
   - 返回Agent Card对象

**结果**: `card = { name: "weather-agent", endpoints: { sendSubscribe: "..." } }`

**步骤3: 提取sendSubscribe端点（第79-81行）**
```javascript
const card = await fetchAgentCard(baseUrl);
const endpoint = card?.endpoints?.sendSubscribe;
if (!endpoint)
  throw new Error(`No sendSubscribe endpoint in Agent Card for ${baseUrl}`);
```
- **endpoint**: `"http://localhost:3001/tasks/sendSubscribe"`

**步骤4: 发送POST请求到子Agent（第87-92行）**
```javascript
const r = await fetch(endpoint, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ input }),
  signal: ac.signal,
});
```

**HTTP请求详情**:
```
POST http://localhost:3001/tasks/sendSubscribe HTTP/1.1
Content-Type: application/json

{
  "input": {
    "query": "查询北京明天的天气和到上海的机票"
  }
}
```

**执行时机**: 
- **立即发起**: 不等待，异步执行
- **signal**: 绑定到AbortController，支持超时中止

**步骤5: 验证响应（第93-94行）**
```javascript
if (!r.ok || !r.body)
  throw new Error(`sendSubscribe failed: ${endpoint} ${r.status}`);
```
- **检查**: HTTP状态码和响应体
- **如果失败**: 抛出错误，Promise.all会捕获

**步骤6: 读取SSE流（第96-131行）**

**代码**:
```javascript
const reader = r.body.getReader();
const decoder = new TextDecoder("utf-8");
let buf = "";

while (true) {
  const { value, done } = await reader.read();
  if (done) break;
  buf += decoder.decode(value, { stream: true });

  // SSE events separated by \n\n; we only parse "data: ..."
  let idx;
  while ((idx = buf.indexOf("\n\n")) >= 0) {
    const event = buf.slice(0, idx);
    buf = buf.slice(idx + 2);

    const lines = event.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed.startsWith("data:")) continue;
      const jsonStr = trimmed.slice(5).trim();
      if (!jsonStr) continue;

      let msg;
      try {
        msg = JSON.parse(jsonStr);
      } catch {
        continue;
      }

      if (msg?.type === "final") {
        if (msg.error) throw new Error(msg.error);
        return msg.artifact; // {kind, data}
      }
    }
  }
}
```

**执行过程**:
1. **创建流读取器**: `getReader()` 获取ReadableStream的reader
2. **循环读取**: 
   - `reader.read()` 异步读取数据块
   - 使用TextDecoder解码为字符串
   - 累积到 `buf` 缓冲区
3. **解析SSE事件**:
   - SSE事件以 `\n\n` 分隔
   - 查找 `data:` 开头的行
   - 提取JSON字符串并解析
4. **检查final消息**:
   - 如果 `msg.type === "final"`，返回 `msg.artifact`
   - 如果 `msg.error` 存在，抛出错误

**步骤7: 超时处理（第134-142行）**
```javascript
} catch (e) {
  if (String(e?.name) === "AbortError") {
    throw new Error(`sendSubscribe timeout after ${timeoutMs}ms: ${baseUrl}`);
  }
  throw e;
} finally {
  clearTimeout(timer);
}
```
- **AbortError**: 超时触发AbortController时产生
- **清理**: finally块确保清除定时器

---

#### 6.2 并行执行时间线

**Weather-Agent调用时间线**:
```
T0: sendSubscribe(WEATHER_AGENT_URL, { query }) 开始
T1: 创建AbortController和定时器（~0ms）
T2: fetchAgentCard() 开始
    ├─ T2.1: 检查缓存（~0ms）
    ├─ T2.2: GET /.well-known/agent-card.json（~5-50ms，网络延迟）
    └─ T2.3: 解析并缓存（~1ms）
T3: POST /tasks/sendSubscribe 开始（~1ms）
T4: 等待子Agent响应（连接建立）
T5-TN: 读取SSE流，等待final消息（详见阶段7）
TN+1: 收到final消息，返回artifact
```

**Flight-Agent调用时间线**: 类似，但并行执行

**总耗时**: max(Weather-Agent耗时, Flight-Agent耗时) + 少量开销

**典型耗时**:
- Agent Card获取: 5-50ms（首次）或 <1ms（缓存）
- OpenAI API调用: 500-3000ms（取决于模型和网络）
- 总耗时: 通常 1-5秒

---

### 阶段7: 子Agent处理请求

**位置**: `weather-agent/server.js` 和 `flight-agent/server.js`

**执行时机**: Main-Agent发送 `POST /tasks/sendSubscribe` 请求到达子Agent时

**并行执行**: Weather-Agent和Flight-Agent同时处理各自的请求

---

#### 7.1 Weather-Agent详细流程

**位置**: `weather-agent/server.js` 第31-87行

**执行顺序**:

**步骤1: 路由匹配（第31行）**
```javascript
app.post("/tasks/sendSubscribe", async (req, res) => {
```
- **时机**: Express路由匹配到 `POST /tasks/sendSubscribe`
- **请求来源**: Main-Agent的 `sendSubscribe()` 函数

**步骤2: 提取输入数据（第32-34行）**
```javascript
const { input } = req.body || {};
const prompt = String(input?.query || "");
```
- **req.body**: Express中间件已解析JSON
- **结果**: `prompt = "查询北京明天的天气和到上海的机票"`

**步骤3: 设置SSE响应头（第36-40行）**
```javascript
res.status(200);
res.setHeader("Content-Type", "text/event-stream; charset=utf-8");
res.setHeader("Cache-Control", "no-cache, no-transform");
res.setHeader("Connection", "keep-alive");
res.write(":\n\n");
```
- **时机**: 立即执行（同步）
- **作用**: 
  - 设置HTTP状态码200
  - 设置Content-Type为 `text/event-stream`
  - 禁用缓存
  - 保持连接打开
  - 发送SSE初始空消息

**步骤4: 生成任务ID并发送开始状态（第42-44行）**
```javascript
const taskId = `w_${Date.now()}`;
sseWrite(res, { type: "status", taskId, stage: "started" });
```

**sseWrite函数**（第16-18行）:
```javascript
function sseWrite(res, obj) {
  res.write(`data: ${JSON.stringify(obj)}\n\n`);
}
```

**发送的SSE消息**:
```
data: {"type":"status","taskId":"w_1705123456789","stage":"started"}

```

**执行时机**: 立即发送（同步）

**步骤5: 调用OpenAI API（第47-57行）**

**代码**:
```javascript
const completion = await openai.chat.completions.create({
  model: "turing/gpt-4o-mini",
  messages: [
    {
      role: "system",
      content: "你是天气子Agent。请输出严格JSON，不要多余文本。字段: city, date, summary, temp_c_low, temp_c_high, precip_prob, advice。",
    },
    { role: "user", content: prompt },
  ],
});
```

**执行过程**:
1. **创建OpenAI客户端**（第11-14行）:
   ```javascript
   const openai = new OpenAI({
     apiKey: process.env.OPENAI_API_KEY,
     baseURL: process.env.OPENAI_BASE_URL,
   });
   ```

2. **发起API请求**:
   - **HTTP请求**: POST到OpenAI API
   - **模型**: `turing/gpt-4o-mini`
   - **消息**: System Prompt + User Query
   - **等待**: 异步等待OpenAI响应

3. **OpenAI处理**:
   - 接收请求
   - LLM推理生成响应
   - 返回JSON格式的天气信息

**执行时机**: 
- **开始**: 立即发起（异步）
- **等待**: 通常500-3000ms（取决于模型和网络）
- **完成**: 收到OpenAI响应

**步骤6: 解析OpenAI响应（第59-74行）**

**代码**:
```javascript
const raw = completion.choices?.[0]?.message?.content?.trim() || "{}";
let data;
try {
  data = JSON.parse(raw);
} catch {
  // 兜底处理：如果JSON解析失败，使用降级结构
  data = {
    city: "unknown",
    date: "unknown",
    summary: raw.slice(0, 120),
    temp_c_low: null,
    temp_c_high: null,
    precip_prob: null,
    advice: "无法解析严格JSON，已降级为摘要。",
  };
}
```

**执行过程**:
1. **提取响应内容**: 从OpenAI响应中提取文本
2. **尝试JSON解析**: 
   - **成功**: `data` 包含解析后的JSON对象
   - **失败**: 使用降级结构，将原始文本放入summary

**典型响应示例**:
```json
{
  "city": "北京",
  "date": "2024-01-15",
  "summary": "晴天，温度适宜",
  "temp_c_low": 5,
  "temp_c_high": 15,
  "precip_prob": 10,
  "advice": "适合出行"
}
```

**步骤7: 发送完成状态（第76行）**
```javascript
sseWrite(res, { type: "status", taskId, stage: "completed" });
```

**发送的SSE消息**:
```
data: {"type":"status","taskId":"w_1705123456789","stage":"completed"}

```

**步骤8: 发送最终结果（第77-81行）**
```javascript
sseWrite(res, {
  type: "final",
  taskId,
  artifact: { kind: "weather", data },
});
```

**发送的SSE消息**:
```
data: {"type":"final","taskId":"w_1705123456789","artifact":{"kind":"weather","data":{"city":"北京","date":"2024-01-15",...}}}

```

**步骤9: 结束响应（第82行）**
```javascript
res.end();
```
- **时机**: 最终消息发送后立即执行
- **作用**: 关闭HTTP响应流

**Main-Agent接收**: 
- `sendSubscribe()` 函数中的SSE流读取器检测到 `type: "final"`
- 返回 `msg.artifact` 给调用者

---

#### 7.2 Flight-Agent详细流程

**位置**: `flight-agent/server.js` 第30-90行

**执行流程**: 与Weather-Agent类似，但有以下区别：

**区别1: System Prompt（第49-50行）**
```javascript
content: "你是机票子Agent（当前无真实航司数据）。请输出严格JSON，不要多余文本。字段: from, to, date, options(数组, 每项含 id, airline, depart, arrive, duration, price_cny, notes)。返回3条options。",
```

**区别2: 数据结构**
- `artifact.kind = "flights"`
- `data` 包含 `from`, `to`, `date`, `options` 数组

**区别3: 任务ID前缀**
- `taskId = "f_" + Date.now()`（Flight-Agent）
- `taskId = "w_" + Date.now()`（Weather-Agent）

**返回的Artifact示例**:
```json
{
  "type": "final",
  "taskId": "f_1705123456789",
  "artifact": {
    "kind": "flights",
    "data": {
      "from": "北京",
      "to": "上海",
      "date": "2024-01-15",
      "options": [
        {
          "id": "flight-1",
          "airline": "中国国航",
          "depart": "08:00",
          "arrive": "10:30",
          "duration": "2h30m",
          "price_cny": 1200,
          "notes": "经济舱"
        },
        {
          "id": "flight-2",
          "airline": "东方航空",
          "depart": "10:00",
          "arrive": "12:30",
          "duration": "2h30m",
          "price_cny": 1100,
          "notes": "经济舱"
        },
        {
          "id": "flight-3",
          "airline": "南方航空",
          "depart": "14:00",
          "arrive": "16:30",
          "duration": "2h30m",
          "price_cny": 1300,
          "notes": "经济舱"
        }
      ]
    }
  }
}
```

---

#### 7.3 并行执行时间线

**Weather-Agent时间线**:
```
T0: POST /tasks/sendSubscribe 到达
T1: 设置SSE响应头（~1ms）
T2: 发送status started（~1ms）
T3: 调用OpenAI API（异步开始）
T4-TN: OpenAI处理中（500-3000ms）
TN+1: 收到OpenAI响应
TN+2: 解析JSON（~1ms）
TN+3: 发送status completed（~1ms）
TN+4: 发送final消息（~1ms）
TN+5: res.end()（~1ms）
```

**Flight-Agent时间线**: 类似，但并行执行

**总耗时**: max(Weather-Agent耗时, Flight-Agent耗时)

**典型场景**:
- Weather-Agent: 800ms
- Flight-Agent: 1200ms
- **总耗时**: 1200ms（等待最慢的完成）

---

### 阶段8: Main-Agent 聚合结果并生成A2UI更新

**位置**: `main-agent/server.js` 第455-463行（调用） + 第310-396行（sendResultUI函数）

**执行时机**: Promise.all完成，两个子Agent都返回artifact后

---

#### 8.1 接收子Agent返回的Artifact

**时机**: `Promise.all` 完成，两个异步调用都返回结果

**代码位置**: `server.js` 第457-460行
```javascript
const [weatherArtifact, flightArtifact] = await Promise.all([
  sendSubscribe(WEATHER_AGENT_URL, { query }),
  sendSubscribe(FLIGHT_AGENT_URL, { query }),
]);
```

**执行过程**:
- **等待**: 直到两个 `sendSubscribe()` 都完成
- **返回**: 
  - `weatherArtifact = { kind: "weather", data: {...} }`
  - `flightArtifact = { kind: "flights", data: {...} }`

**典型artifact结构**:
```javascript
weatherArtifact = {
  kind: "weather",
  data: {
    city: "北京",
    date: "2024-01-15",
    summary: "晴天，温度适宜",
    temp_c_low: 5,
    temp_c_high: 15,
    precip_prob: 10,
    advice: "适合出行"
  }
}

flightArtifact = {
  kind: "flights",
  data: {
    from: "北京",
    to: "上海",
    date: "2024-01-15",
    options: [
      { id: "flight-1", airline: "中国国航", depart: "08:00", arrive: "10:30", price_cny: 1200, ... },
      { id: "flight-2", airline: "东方航空", depart: "10:00", arrive: "12:30", price_cny: 1100, ... },
      { id: "flight-3", airline: "南方航空", depart: "14:00", arrive: "16:30", price_cny: 1300, ... }
    ]
  }
}
```

**步骤2: 调用sendResultUI函数（第463行）**
```javascript
sendResultUI(surfaceId, conn.res, weatherArtifact, flightArtifact);
```
- **时机**: 立即调用（同步）
- **参数**: surfaceId, SSE响应对象, 两个artifact

---

#### 8.2 sendResultUI函数详细执行

**函数签名**: `server.js` 第310行
```javascript
function sendResultUI(surfaceId, res, weatherArtifact, flightArtifact)
```

**执行顺序**:

**步骤1: 处理天气数据（第312-353行）**

**提取数据（第312行）**:
```javascript
const w = weatherArtifact?.data ?? {};
```

**构建显示文本（第313行）**:
```javascript
const tempText = buildWeatherText(w);
```

**buildWeatherText函数**（第255-271行）:
```javascript
function buildWeatherText(w) {
  const low = Number(w?.temp_c_low);
  const high = Number(w?.temp_c_high);

  // 优先用温度区间
  if (Number.isFinite(low) && Number.isFinite(high)) {
    return `${low} ~ ${high} °C`;
  }

  // 次选：summary
  if (w?.summary) return String(w.summary);

  // 次选：advice
  if (w?.advice) return String(w.advice);

  return "（未返回天气信息）";
}
```

**执行过程**:
- 检查 `temp_c_low` 和 `temp_c_high` 是否有效
- **如果有效**: 返回 `"5 ~ 15 °C"`
- **如果无效**: 尝试使用 `summary` 或 `advice`
- **如果都无效**: 返回占位文本

**发送天气数据模型更新（第315-353行）**:
```javascript
sseSend(res, {
  dataModelUpdate: {
    surfaceId,
    path: "/weather",
    contents: [
      { key: "city", valueString: String(w.city ?? "") },
      { key: "date", valueString: String(w.date ?? "") },
      { key: "summary", valueString: String(w.summary ?? "") },
      { key: "advice", valueString: String(w.advice ?? "") },
      { key: "temp_c_low", valueNumber: Number.isFinite(Number(w.temp_c_low)) ? Number(w.temp_c_low) : 0 },
      { key: "temp_c_high", valueNumber: Number.isFinite(Number(w.temp_c_high)) ? Number(w.temp_c_high) : 0 },
      { key: "precip_prob", valueNumber: Number.isFinite(Number(w.precip_prob)) ? Number(w.precip_prob) : 0 },
      { key: "temp_text", valueString: tempText },
      { key: "precip_text", valueString: w.precip_prob != null ? `${w.precip_prob}%` : "" },
    ],
  },
});
```

**发送的SSE消息**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/weather","contents":[{"key":"city","valueString":"北京"},{"key":"date","valueString":"2024-01-15"},{"key":"temp_text","valueString":"5 ~ 15 °C"},...]}}

```

**执行时机**: 立即发送（同步）

**步骤2: 处理机票数据（第355-395行）**

**提取数据（第356行）**:
```javascript
const f = flightArtifact?.data ?? {};
```

**规范化机票选项（第357行）**:
```javascript
const normalized = normalizeFlightOptions(f.options);
```

**normalizeFlightOptions函数**（第273-308行）:
```javascript
function normalizeFlightOptions(rawOptions) {
  const list = Array.isArray(rawOptions) ? rawOptions : [];
  const out = [];

  for (let i = 0; i < list.length; i++) {
    const o = list[i];
    if (!o || typeof o !== "object") continue;  // 跳过非对象

    const airline = String(o.airline ?? o.carrier ?? o.airlineName ?? "").trim();
    const depart = String(o.depart ?? o.departTime ?? "").trim();
    const arrive = String(o.arrive ?? o.arriveTime ?? "").trim();
    const notes = cleanNote(o.notes ?? o.note ?? "");

    // 处理价格
    let price = o.price_cny ?? o.price ?? o.priceCny;
    if (typeof price === "string") price = price.replace(/[^\d.]/g, "");
    const priceNum = price != null && price !== "" ? Number(price) : null;

    // 如果关键信息全空，跳过
    if (!airline && !depart && !arrive && priceNum == null && !notes) continue;

    out.push({ airline, depart, arrive, priceNum, notes });
  }

  return out;
}
```

**执行过程**:
- 遍历原始options数组
- 提取并规范化每个字段（airline, depart, arrive, price, notes）
- 清洗价格字符串（去除非数字字符）
- 过滤无效选项（所有关键字段都为空）

**构建显示文本（第359-371行）**:
```javascript
const optionsText = normalized.length
  ? normalized
      .map((o, idx) => {
        const time = [o.depart, o.arrive].filter(Boolean).join("–");
        const price = o.priceNum != null ? `¥${o.priceNum}` : "";
        const notes = o.notes ? `（${o.notes}）` : "";
        return `${idx + 1}. ${[o.airline, time, price]
          .filter(Boolean)
          .join(" ")} ${notes}`.trim();
      })
      .join("\n")
  : "（暂无选项）";
```

**执行过程**:
- 遍历规范化后的选项
- 格式化每条选项：`"1. 中国国航 08:00–10:30 ¥1200 （经济舱）"`
- 用换行符连接所有选项

**发送机票数据模型更新（第373-395行）**:
```javascript
sseSend(res, {
  dataModelUpdate: {
    surfaceId,
    path: "/flights",
    contents: [
      { key: "from", valueString: String(f.from ?? "") },
      { key: "to", valueString: String(f.to ?? "") },
      { key: "date", valueString: String(f.date ?? "") },
      { key: "options", valueJson: Array.isArray(f.options) ? f.options : [] },
      { key: "options_text", valueString: optionsText },
      { key: "raw", valueString: safeJson(flightArtifact?.data ?? {}) },
    ],
  },
});
```

**发送的SSE消息**:
```
data: {"dataModelUpdate":{"surfaceId":"main","path":"/flights","contents":[{"key":"from","valueString":"北京"},{"key":"to","valueString":"上海"},{"key":"options_text","valueString":"1. 中国国航 08:00–10:30 ¥1200 （经济舱）\n2. 东方航空 10:00–12:30 ¥1100 （经济舱）\n3. 南方航空 14:00–16:30 ¥1300 （经济舱）"},...]}}

```

**执行时机**: 立即发送（同步）

**步骤3: 返回HTTP响应（第465行）**
```javascript
return res.json({ ok: true });
```
- **时机**: sendResultUI完成后立即执行
- **作用**: 结束POST /ui/event请求，返回成功状态

---

#### 8.3 执行时间线

**Main-Agent处理时间线**:
```
T0: Promise.all完成，收到两个artifact
T1: 调用sendResultUI()（~0ms）
T2: 处理天气数据（~1ms）
    ├─ buildWeatherText()（~0.5ms）
    └─ 发送dataModelUpdate /weather（~0.5ms）
T3: 处理机票数据（~2ms）
    ├─ normalizeFlightOptions()（~1ms）
    ├─ 构建optionsText（~0.5ms）
    └─ 发送dataModelUpdate /flights（~0.5ms）
T4: 返回HTTP响应（~0ms）
```

**总耗时**: 通常 < 5ms（数据处理和SSE发送）

**重要**: 两条SSE消息是**顺序发送**的，但几乎同时到达前端（网络延迟相同）

---

### 阶段9: 前端接收A2UI更新并重新渲染

**位置**: `main-agent/web/app.js` 第198-243行（消息处理） + 第79-172行（DOM构建）

**执行时机**: 服务器发送 `dataModelUpdate` SSE消息时，浏览器EventSource触发 `onmessage`

**消息接收顺序**: 
1. 消息1: `dataModelUpdate /weather`（天气数据）
2. 消息2: `dataModelUpdate /flights`（机票数据）

---

#### 9.1 接收消息1: 天气数据更新

**时机**: 服务器发送第一条 `dataModelUpdate /weather` 消息

**代码执行**: `app.js` 第198-225行

**步骤1: 解析消息（第199-204行）**
```javascript
es.onmessage = (evt) => {
  let msg;
  try {
    msg = JSON.parse(evt.data);
  } catch {
    return;
  }
```
- **evt.data**: `'{"dataModelUpdate":{"surfaceId":"main","path":"/weather","contents":[...]}}'`
- **结果**: `msg = { dataModelUpdate: { surfaceId: "main", path: "/weather", contents: [...] } }`

**步骤2: 处理dataModelUpdate（第216-225行）**
```javascript
if (msg.dataModelUpdate) {
  // 严格：只接受 path + contents
  const basePath = msg.dataModelUpdate.path;
  const contents = msg.dataModelUpdate.contents;
  if (typeof basePath === "string" && Array.isArray(contents)) {
    applyContents(basePath, contents);
  } else {
    console.warn("Ignored non-v0.8 dataModelUpdate:", msg.dataModelUpdate);
  }
}
```

**重要变化**: 
- **严格v0.8-like**: 只接受 `path + contents` 格式
- **移除兼容**: 不再支持旧的 `patch` 格式
- **验证**: 如果格式不正确，输出警告并忽略

**applyContents执行**（第56-77行）:
- `basePath = "/weather"`
- `contents = [{ key: "city", valueString: "北京" }, { key: "temp_text", valueString: "5 ~ 15 °C" }, ...]`
- 遍历contents，调用 `setPath()` 更新数据模型

**数据模型更新**:
```javascript
state.dataModel.weather.city = "北京"
state.dataModel.weather.date = "2024-01-15"
state.dataModel.weather.temp_text = "5 ~ 15 °C"
state.dataModel.weather.summary = "晴天，温度适宜"
// ... 其他字段
```

**步骤3: 触发渲染（第238行）**
```javascript
if (msg.surfaceUpdate || msg.dataModelUpdate) render();
```

**render函数执行**（第174-179行）:
```javascript
function render() {
  if (!state.rootId) return;  // ✅ rootId="root"，继续执行
  const app = document.getElementById("app");
  app.innerHTML = "";  // 清空容器
  app.appendChild(buildElement(state.rootId));  // 重新构建DOM
}
```

**buildElement("root")执行**:
- 递归构建所有子组件
- **关键**: `buildElement("weatherCard")` 时，`resolveText()` 读取 `/weather/temp_text`
- **结果**: `<pre>5 ~ 15 °C</pre>`（而不是之前的"（等待查询）"）

**此时状态**:
- 天气卡片已更新显示新数据
- 机票卡片仍显示"查询中..."（等待下一条消息）

---

#### 9.2 接收消息2: 机票数据更新

**时机**: 服务器发送第二条 `dataModelUpdate /flights` 消息（通常在消息1后几毫秒）

**代码执行**: 类似消息1的处理流程

**步骤1: 解析消息**
- `msg = { dataModelUpdate: { surfaceId: "main", path: "/flights", contents: [...] } }`

**步骤2: 更新数据模型**
```javascript
state.dataModel.flights.from = "北京"
state.dataModel.flights.to = "上海"
state.dataModel.flights.options_text = "1. 中国国航 08:00–10:30 ¥1200 （经济舱）\n2. 东方航空 10:00–12:30 ¥1100 （经济舱）\n3. 南方航空 14:00–16:30 ¥1300 （经济舱）"
```

**步骤3: 触发渲染**
- `render()` 再次执行
- 清空 `#app` 并重新构建DOM
- **关键**: `buildElement("flightCard")` 时，`resolveText()` 读取 `/flights/options_text`
- **结果**: `<pre>1. 中国国航 08:00–10:30 ¥1200 （经济舱）\n2. 东方航空 10:00–12:30 ¥1100 （经济舱）\n3. 南方航空 14:00–16:30 ¥1300 （经济舱）</pre>`

**最终DOM结构**:
```html
<div id="app">
  <div class="col">
    <h2>A2A + A2UI(v0.8-like) Demo</h2>
    <div>
      <div class="muted">输入需求（天气/机票）</div>
      <input value="查询北京明天的天气和到上海的机票" />
    </div>
    <button>提交</button>
    <div class="col">
      <div class="card">
        <h3>天气</h3>
        <pre>5 ~ 15 °C</pre>  <!-- ✅ 已更新 -->
      </div>
      <div class="card">
        <h3>机票</h3>
        <pre>1. 中国国航 08:00–10:30 ¥1200 （经济舱）
2. 东方航空 10:00–12:30 ¥1100 （经济舱）
3. 南方航空 14:00–16:30 ¥1300 （经济舱）</pre>  <!-- ✅ 已更新 -->
      </div>
    </div>
  </div>
</div>
```

---

#### 9.3 消息接收和渲染时间线

**前端处理时间线**:
```
T0: 服务器发送消息1 dataModelUpdate /weather
T1: 浏览器EventSource触发onmessage（消息1）
    ├─ 解析JSON（~0.5ms）
    ├─ 更新dataModel.weather（~0.5ms）
    └─ 调用render()（~10-50ms）
        ├─ 清空#app
        ├─ buildElement("root")
        │   ├─ buildElement("weatherCard")
        │   │   └─ resolveText("/weather/temp_text") → "5 ~ 15 °C"
        │   └─ buildElement("flightCard")
        │       └─ resolveText("/flights/options_text") → "查询中..."
        └─ 添加到DOM
        ✅ 天气卡片显示新数据，机票卡片仍显示"查询中..."

T2: 服务器发送消息2 dataModelUpdate /flights（T0后几毫秒）
T3: 浏览器EventSource触发onmessage（消息2）
    ├─ 解析JSON（~0.5ms）
    ├─ 更新dataModel.flights（~0.5ms）
    └─ 调用render()（~10-50ms）
        ├─ 清空#app
        ├─ buildElement("root")
        │   ├─ buildElement("weatherCard")
        │   │   └─ resolveText("/weather/temp_text") → "5 ~ 15 °C"
        │   └─ buildElement("flightCard")
        │       └─ resolveText("/flights/options_text") → "1. 中国国航..."
        └─ 添加到DOM
        ✅ 两个卡片都显示最终数据
```

**总耗时**: 
- 消息1处理: ~15-55ms
- 消息2处理: ~15-55ms（在消息1后几毫秒）
- **用户感知**: 通常看到两次快速更新，或只看到最终结果（如果更新太快）

**优化提示**: 
- 当前实现每次 `dataModelUpdate` 都会触发完整重渲染
- 可以优化为增量更新，只更新变化的DOM节点

---

### 阶段10: 用户看到最终结果

**用户界面更新**:

1. **天气卡片**
   - 标题："天气"
   - 内容：显示温度、城市、日期等信息

2. **机票卡片**
   - 标题："机票"
   - 内容：显示格式化的机票选项列表，包含：
     - 航空公司
     - 出发/到达时间
     - 价格
     - 备注信息

3. **用户可以继续交互**
   - 修改输入框内容
   - 再次点击提交按钮
   - 重复上述流程

---

## 关键技术点

### 1. SSE（Server-Sent Events）
- **用途**: 实现服务器到客户端的单向实时通信
- **优势**: 自动重连、简单易用、HTTP协议支持
- **格式**: `data: {JSON}\n\n`

### 2. A2UI协议（v0.8-like）
- **Component Catalog**: 定义UI组件结构
- **Data Model**: 基于路径的数据模型（如 `/form/query`）
- **Data Binding**: 组件通过 `path` 绑定数据模型
- **Incremental Updates**: 通过 `dataModelUpdate` 增量更新

### 3. A2A协议
- **Agent Card**: `.well-known/agent-card.json` 定义Agent能力
- **sendSubscribe**: SSE流式订阅接口
- **Artifact**: 标准化的结果格式 `{kind, data}`

### 4. 错误处理
- **超时机制**: A2A调用默认20秒超时
- **JSON解析失败**: 子Agent提供降级数据结构
- **连接丢失**: SSE自动重连机制

---

## 数据流图

```
用户输入: "查询北京明天的天气和到上海的机票"
    ↓
前端: POST /ui/event {userAction: {name: "submit", context: {query: "..."}}}
    ↓
Main-Agent: 显示"查询中..."
    ↓
Main-Agent: 并行调用
    ├─→ Weather-Agent: POST /tasks/sendSubscribe {input: {query: "..."}}
    │       ↓
    │   Weather-Agent: GET /.well-known/agent-card.json
    │       ↓
    │   Weather-Agent: POST /tasks/sendSubscribe (SSE)
    │       ↓
    │   Weather-Agent: OpenAI API调用
    │       ↓
    │   OpenAI: 返回JSON天气数据
    │       ↓
    │   Weather-Agent: SSE发送 {type: "final", artifact: {kind: "weather", data: {...}}}
    │       ↓
    │   Main-Agent: 接收weatherArtifact
    │
    └─→ Flight-Agent: POST /tasks/sendSubscribe {input: {query: "..."}}
            ↓
        Flight-Agent: GET /.well-known/agent-card.json
            ↓
        Flight-Agent: POST /tasks/sendSubscribe (SSE)
            ↓
        Flight-Agent: OpenAI API调用
            ↓
        OpenAI: 返回JSON机票数据
            ↓
        Flight-Agent: SSE发送 {type: "final", artifact: {kind: "flights", data: {...}}}
            ↓
        Main-Agent: 接收flightArtifact
    ↓
Main-Agent: 聚合结果，生成A2UI dataModelUpdate
    ↓
Main-Agent: SSE发送 dataModelUpdate 到前端
    ↓
前端: 更新state.dataModel，触发render()
    ↓
前端: DOM更新，显示结果
    ↓
用户: 看到天气和机票信息
```

---

## 文件结构说明

```
a2ui-a2a-openai-project/
├── main-agent/
│   ├── server.js          # Main-Agent服务器，处理A2UI和A2A协议
│   └── web/
│       ├── index.html     # 前端HTML页面
│       └── app.js         # 前端JavaScript，A2UI渲染器
├── weather-agent/
│   └── server.js          # 天气子Agent，调用OpenAI API
├── flight-agent/
│   └── server.js          # 机票子Agent，调用OpenAI API
└── package.json           # 项目依赖配置
```

---

## 环境变量配置

```bash
# Main-Agent端口（默认3000）
MAIN_PORT=3000

# Weather-Agent端口（默认3001）
WEATHER_PORT=3001
WEATHER_AGENT_URL=http://localhost:3001

# Flight-Agent端口（默认3002）
FLIGHT_PORT=3002
FLIGHT_AGENT_URL=http://localhost:3002

# OpenAI配置
OPENAI_API_KEY=your_api_key
OPENAI_BASE_URL=https://api.openai.com/v1
```

---

## 总结

本系统实现了完整的 **Agent-to-Agent (A2A)** 和 **Agent-to-UI (A2UI)** 协议栈：

1. **前端** 通过SSE接收A2UI格式的UI定义和数据更新
2. **Main-Agent** 作为协调者，处理用户交互并调用子Agent
3. **子Agent** 通过A2A协议提供服务，调用OpenAI API获取智能结果
4. **结果聚合** 后通过A2UI协议更新前端UI
5. **用户** 看到实时更新的结果，可继续交互

整个流程实现了**解耦**、**可扩展**、**实时更新**的Agent协作架构。

